# TasmFORdump-me-
репозиторий с MDшниками про TASM для тупых(меня)
---

[[0.Кратко про Tasm]]
[[1.Про регистры новичку]]
[[2.Вывод строк]]
[[3.Про int 21h новичку]]
[[4.Макросы]]
[[5.Арифметика Tasm]]
[[6.Условные переходы]]
# 0.Кратко про Tasm

## 1. Введение
**Assembler** — это язык низкого уровня, где команды практически напрямую соответствуют машинным инструкциям процессора.
**TASM (Turbo Assembler)** — популярный компилятор от Borland для архитектуры x86. Обычно используется для написания 16-битных программ под DOS.

## 2. Подготовка рабочего места
Поскольку современные ОС (Windows 10/11, macOS, Linux) не поддерживают запуск 16-битных приложений напрямую, вам понадобится эмулятор.

1.  **Скачайте DOSBox** (эмулятор среды MS-DOS).
2.  **Скачайте пакет TASM**. Он должен содержать файлы `TASM.EXE` (компилятор) и `TLINK.EXE` (компоновщик).
3.  **Создайте рабочую папку** (например, `C:\ASM`), положите туда `TASM.EXE`, `TLINK.EXE` и создавайте там свои файлы с кодом (`.asm`).
4.  **Монтирование в DOSBox**:
    *   Запустите DOSBox.
    *   Введите команду: `mount c c:\asm` (где `c:\asm` — путь к вашей папке).
    *   Перейдите на диск C: `c:`

## 3. Структура программы
В TASM удобнее всего использовать **упрощенные директивы сегментации**. Шаблон любой программы выглядит так:

```asm
.model small      ; Модель памяти (код и данные в разных сегментах, но < 64Кб)
.stack 100h       ; Выделение стека (256 байт)

.data
    ; СЕГМЕНТ ДАННЫХ
    ; Здесь объявляются переменные
    peremennaya db 10       ; db = define byte (8 бит)
    message     db 'Hello$' ; Строка

.code
    ; СЕГМЕНТ КОДА
start:              ; Метка начала программы
    ; 1. Инициализация сегмента данных (ОБЯЗАТЕЛЬНО!)
    mov ax, @data
    mov ds, ax

    ; 2. ТЕЛО ПРОГРАММЫ
    ; Здесь пишется ваш код

    ; 3. Завершение программы (Выход в DOS)
    mov ah, 4Ch     ; Функция DOS 4Ch - завершить процесс
    int 21h         ; Вызов прерывания

end start           ; Конец файла и указание точки входа
```

## 4. Основные понятия

### Регистры (Ваши "карманы" для данных)
Процессор x86 имеет регистры общего назначения (16 бит):
*   **AX (Accumulator):** Для арифметики и ввода/вывода. Делится на `AH` (старший байт) и `AL` (младший).
*   **BX (Base):** Часто используется для адресации массивов.
*   **CX (Count):** Счётчик для циклов.
*   **DX (Data):** Для умножения/деления и вывода данных.

### Основные команды
*   `MOV куда, что` — Пересылка данных (присваивание).
    *   *Пример:* `mov ax, 5` (AX = 5).
*   `ADD куда, что` — Сложение.
    *   *Пример:* `add ax, bx` (AX = AX + BX).
*   `SUB куда, что` — Вычитание.
*   `INC куда` / `DEC куда` — Увеличить/уменьшить на 1.
*   `INT номер` — Вызов прерывания (обращение к системе).

## 5. Работа с прерыванием INT 21h (Функции DOS)
Взаимодействие с экраном и клавиатурой происходит через прерывание `21h`. Перед вызовом нужно положить номер функции в регистр **AH**.

**Самые частые функции:**

| Функция (AH) | Описание | Параметры |
| :--- | :--- | :--- |
| **09h** | Вывод строки на экран | `DX` = адрес строки (строка должна оканчиваться знаком `$`) |
| **02h** | Вывод одного символа | `DL` = код символа (ASCII) |
| **01h** | Ввод символа с эхом | Результат сохраняется в `AL` |
| **4Ch** | Выход из программы | - |

## 6. Пример №1: "Hello, World!"
Создайте файл `hello.asm` и напишите:

```asm
.model small
.stack 100h

.data
    helloStr db 'Privet, mir!', 0Dh, 0Ah, '$' 
    ; 0Dh, 0Ah - это переход на новую строку
    ; $ - признак конца строки для функции 09h

.code
start:
    ; Инициализация DS
    mov ax, @data
    mov ds, ax

    ; Вывод строки
    mov ah, 09h         ; Функция вывода строки
    lea dx, helloStr    ; Загружаем адрес строки в DX (LEA = Load Effective Address)
    int 21h             ; "Дёрнуть" DOS

    ; Выход
    mov ah, 4Ch
    int 21h
end start
```

## 7. Компиляция и запуск
В окне DOSBox выполните команды по очереди:

1.  **Компиляция** (создает объектный файл `.OBJ`):
    ```bash
    tasm hello.asm
    ```
    *Если ошибок нет, вы увидите сообщение "Error messages: None".*

2.  **Линковка** (создает исполняемый файл `.EXE`):
    ```bash
    tlink hello.obj
    ```

3.  **Запуск**:
    ```bash
    hello.exe
    ```

## 8. Пример №2: Сложение двух цифр
Программа, которая складывает 2 и 3, переводит результат в символ ASCII и выводит на экран.

```asm
.model small
.stack 100h
.data
    ; тут пусто, переменные не нужны
.code
start:
    mov ax, @data
    mov ds, ax

    mov al, 2       ; Положить 2 в AL
    add al, 3       ; Прибавить 3 к AL. Теперь AL = 5

    ; Чтобы вывести цифру '5' на экран, нужно получить её ASCII код.
    ; Код '0' = 30h (48), '1' = 31h... '5' = 35h.
    ; Поэтому прибавляем 30h (или символ '0') к числу.
    add al, '0'     ; Превращаем число 5 в символ '5'

    mov dl, al      ; Для вывода символа (функция 02h) код должен быть в DL
    mov ah, 02h     ; Функция вывода символа
    int 21h

    ; Выход
    mov ah, 4Ch
    int 21h
end start
```

## 9. Советы для новичка
1.  **`MOV DS, AX`** — забыть эти две строчки в начале — самая частая ошибка. Без них программа не увидит ваши переменные.
2.  **Размерность**: Нельзя делать `mov ax, al` (16 бит в 8 бит) или `mov al, bx`. Операнды должны быть одного размера.
3.  **Комметарии**: Ассемблер сложен для чтения. Пишите комментарии после `;` к каждой строке, описывая логику, а не команду (Плохо: *; прибавить 1*. Хорошо: *; переход к следующему элементу массива*).
4.  **Turbo Debugger (TD)**: Если программа падает или считает неправильно, используйте отладчик. Запуск: `td filename.exe`. Клавиша `F8` позволяет идти по шагам.
---
---
# 1.Про регистры новичку

В процессоре 8086 (с которым мы работаем в TASM под DOS) регистров не так уж много — всего **14 штук** основных.

Их можно разделить на 4 группы по их "профессии". Все они **16-битные** (вмещают числа от 0 до 65535).

---

### 1. Регистры Общего Назначения (The "Workers")

Этими ты будешь пользоваться 90% времени. Уникальная фишка: их можно делить на две половинки по 8 бит (High и Low).

- **AX (Accumulator — Накопитель)**
    
    - Состав: AH (старший) + AL (младший).
        
    - Зачем: Главный регистр для математики (add, sub, mul) и работы с функциями DOS. Результаты операций чаще всего попадают сюда.
        
- **BX (Base — Базовый)**
    
    - Состав: BH + BL.
        
    - Зачем: Часто используется для хранения адресов (индексов) при работе с массивами. Единственный из этой четверки (кроме BP), который может быть указателем в квадратных скобках: [bx].
        
- **CX (Counter — Счетчик)**
    
    - Состав: CH + CL.
        
    - Зачем: Используется в циклах. Команда loop автоматически уменьшает CX. Также используется при работе со сдвигами битов и строками.
        
- **DX (Data — Данные)**
    
    - Состав: DH + DL.
        
    - Зачем: Вспомогательный. Хранит адреса для функций DOS (как в твоем коде), используется при умножении/делении больших чисел и для работы с портами ввода-вывода.
        

---

### 2. Сегментные Регистры (The "Maps")

Они указывают на начало больших блоков памяти ("районов"). Мы их обсуждали в теме про DS. Их **нельзя** делить на половинки.

- **CS (Code Segment):** Указывает, где лежит твой **код**. (Трогать вручную запрещено, процессор сам меняет его при прыжках).
    
- **DS (Data Segment):** Указывает, где лежат **переменные**. (Ты настраиваешь его в начале программы).
    
- **SS (Stack Segment):** Указывает, где лежит **стек**.
    
- **ES (Extra Segment):** Дополнительный сегмент. Нужен, если не хватает DS, или для копирования данных из одного места памяти в другое (используется вместе с DI).
    

---

### 3. Индексные и Указательные (The "Navigators")

Они хранят "смещения" (внутрисегментные адреса). Их тоже нельзя делить на половинки.

- **IP (Instruction Pointer — Указатель команд):**
    
    - Самый важный регистр. Он хранит адрес **следующей команды**, которую выполнит процессор. Он работает в паре с CS.
        
    - Важно: Ты не можешь записать в него данные (mov ip, ... — ошибка). Он меняется сам, когда программа идет вперед, или при командах перехода (jmp, call).
        
- **SP (Stack Pointer — Указатель стека):**
    
    - Указывает на "верхушку" стека. Когда ты делаешь push, SP уменьшается. Когда pop — увеличивается.
        
- **BP (Base Pointer — Базовый указатель):**
    
    - Похож на SP, но используется программистом, чтобы гулять по стеку (читать аргументы функций, локальные переменные), не ломая верхушку стека.
        
- **SI (Source Index — Индекс источника):**
    
    - Используется при копировании массивов или строк как адрес "откуда берем". Работает в паре с DS.
        
- **DI (Destination Index — Индекс назначения):**
    
    - Используется при копировании как адрес "куда кладем". Работает в паре с ES.
        

---

### 4. Регистр Флагов (FLAGS)

Это не число, а набор переключателей (битов). Каждый бит означает какое-то состояние после последней операции.

Например, ты сделал вычитание sub ax, bx. Регистр флагов обновится:

- **ZF (Zero Flag):** Включится (1), если результат равен **0**. (Полезно для проверок "равно ли?").
    
- **CF (Carry Flag):** Флаг переноса. Включится, если при сложении произошло переполнение (число стало больше 255 или 65535).
    
- **SF (Sign Flag):** Включится, если результат стал **отрицательным**.
    
- **OF (Overflow Flag):** Переполнение для чисел со знаком (сложная тема, но важно для математики).
    

---

### Шпаргалка для новичка (Что реально нужно прямо сейчас)

1. **AX, BX, CX, DX** — твои рабочие лошадки.
    
2. **DS** — настроить один раз в начале.
    
3. **IP** — просто знать, что это "курсор выполнения", который бежит по коду.
    
4. **SP** — знать, что он управляет стеком (но не трогать вручную без нужды).
    
5. **Флаги** — ты их не пишешь, ты их "читаешь" командами условных переходов (об этом позже, команды типа je, jz, jnz).

# 2.Вывод строк

Давай разберем эту строку по косточкам. В ней скрыто много фундаментальных принципов работы с памятью и текстом в DOS.

    `Msg db 'Hello, DOSBox!', 13, 10, '$'`
  

Вот что означает каждая часть:

### 1. Msg (Метка / Имя переменной)

Это просто название. Когда программа компилируется, ассемблер заменяет Msg на **адрес в памяти**, где начинается эта строка (смещение относительно начала сегмента данных).  
Ты мог назвать её Text1, MyString или Privet — это не важно.

### 2. db (Define Byte)

Это директива **"Определить Байт"**.  
Ассемблер не знает, что такое "строка" или "текст". Для него всё — это набор байтов.  
Команда db говорит: "Выдели память прямо здесь и положи туда следующие байты".

### 3. 'Hello, DOSBox!' (Данные)

Ассемблер берет каждый символ внутри кавычек, переводит его в числовой код (по таблице ASCII) и записывает в память последовательно.

- H = 72
    
- e = 101
    
- ...и так далее.
    

### 4. 13, 10 (Перенос строки)

Это самое интересное. В DOS (и Windows) понятие "нажать Enter" состоит из двух действий, пришедших от печатных машинок:

- **13 (0Dh) — Carriage Return (CR / Возврат каретки):** Курсор перемещается в самое начало текущей строки (влево).
    
- **10 (0Ah) — Line Feed (LF / Перевод строки):** Курсор сдвигается на одну строку вниз.
    

**Зачем это нужно?**  
Если ты напишешь просто текст без 13, 10, то следующая команда вывода на экран продолжит печатать текст прямо за восклицательным знаком, в одну длинную линию.  
Если написать только 10 (вниз), текст пойдет лесенкой.  
Если только 13 (влево), новый текст напечатается поверх старого.

### 5. '$' (Стоп-сигнал)

Это **терминатор строки**.  
Функция DOS, которую мы используем для вывода текста (mov ah, 09h / int 21h), работает очень просто (и глупо):

1. Она берет адрес начала строки (DX).
    
2. Печатает символ.
    
3. Переходит к следующему байту памяти.
    
4. Печатает его.
    
5. ...повторяет, пока не встретит символ **$**.
    

**Что будет, если забыть $?**  
DOS продолжит печатать всё подряд, что лежит в оперативной памяти за твоей строкой (мусор, куски кода, другие переменные), пока случайно не наткнется на байт со значением $ (код 36). На экране это выглядит как куча странных символов и смайликов.

---

### Как это выглядит в памяти (Hex Dump)

Если ты откроешь эту программу в Turbo Debugger (TD.EXE) и посмотришь дамп памяти (View -> Dump), ты увидишь примерно это:

`48 65 6C 6C 6F 2C 20 44 4F 53 42 6F 78 21 0D 0A 24 H  e  l  l  o  ,     D  O  S  B  o  x  !  CR LF $`
  

- 0D — это 13
    
- 0A — это 10
    
- 24 — это 36 (код символа $)
    

### Резюме

Ты вручную собираешь массив байтов:  
[Текст] + [Вернуть курсор влево] + [Опустить курсор вниз] + [Знак "Стоп" для функции вывода]

# 3.Про int 21h новичку

Прерывание **INT 21h** — это основной шлюз (API) операционной системы MS-DOS. Когда вы пишете `int 21h`, вы просите операционную систему сделать «грязную работу» за вас: обработать нажатие клавиши, записать данные на диск, вывести текст на экран или узнать текущее время.

Всего в INT 21h содержится около 100 функций. Выбор функции осуществляется через регистр **AH**.

Ниже приведен разбор самых полезных функций, разбитых по категориям.

---

## 1. Ввод и вывод на консоль (Клавиатура и Экран)

Это база для любой интерактивной программы.

### Вывод символа (AH = 02h)
Выводит один символ на экран в текущую позицию курсора.
*   **Вход:** `DL` = ASCII код символа.
*   **Пример:** Вывод буквы 'A'.
    ```asm
    mov ah, 02h
    mov dl, 'A'  ; или 65
    int 21h
    ```

### Ввод символа с эхом (AH = 01h)
Программа останавливается и ждет нажатия клавиши. Нажатый символ появляется на экране ("эхо").
*   **Выход:** `AL` = ASCII код нажатой клавиши.
*   **Пример:**
    ```asm
    mov ah, 01h
    int 21h
    ; теперь в AL лежит код символа, например 'Y'
    ```
    *Примечание: Если вам нужно считать символ БЕЗ вывода на экран (например, пароль), используйте функцию **AH = 08h**.*

### Вывод строки (AH = 09h)
Выводит строку текста до знака доллара (`$`).
*   **Вход:** `DX` = адрес начала строки (offset).
*   **Пример:**
    ```asm
    .data
       msg db 'Hello World$'
    .code
       mov ah, 09h
       lea dx, msg
       int 21h
    ```

### Ввод строки в буфер (AH = 0Ah)
Самый сложный, но правильный способ считать строку (например, имя пользователя).
Требует специальной структуры буфера в сегменте данных.

**Структура буфера:**
1.  1-й байт: Максимальная длина ввода (задаете вы).
2.  2-й байт: Реальная длина (заполняет DOS после ввода).
3.  Остальные байты: Сама строка.

**Пример:**
```asm
.data
    ; Буфер на 20 символов + 2 служебных байта
    inputBuf db 20        ; Макс длина (мы разрешаем 20)
             db 0         ; Сюда DOS запишет, сколько реально ввели
             db 20 dup(0) ; Место под символы (забито нулями)
.code
    mov ah, 0Ah
    lea dx, inputBuf
    int 21h
    
    ; После ввода, если юзер ввел "Hi" и нажал Enter:
    ; inputBuf[1] станет равно 2 (длина).
    ; Сама строка начнется с inputBuf[2].
```

---

## 2. Работа с файлами (File Handle)

В современном Ассемблере (начиная с DOS 2.0) работа с файлами идет через **дескрипторы (Handle)**. Это просто число (номер), которое ОС выдает вам при открытии файла.

### Создание файла (AH = 3Ch)
Создает новый файл или обнуляет существующий.
*   **Вход:** `CX` = атрибуты файла (0 - обычный), `DX` = адрес имени файла (строка заканчивается нулем, **ASCIIZ**).
*   **Выход:** Если успешно, `AX` = дескриптор (handle). Если ошибка, флаг `CF` = 1.

### Открытие файла (AH = 3Dh)
*   **Вход:** `AL` = режим доступа (0 - чтение, 1 - запись, 2 - чтение/запись), `DX` = адрес имени файла (ASCIIZ).
*   **Выход:** `AX` = дескриптор.

### Запись в файл (AH = 40h)
*   **Вход:**
    *   `BX` = дескриптор файла (полученный ранее).
    *   `CX` = количество байт для записи.
    *   `DX` = адрес буфера с данными.
*   **Выход:** `AX` = количество реально записанных байт.

### Чтение из файла (AH = 3Fh)
*   **Вход:**
    *   `BX` = дескриптор.
    *   `CX` = сколько байт прочитать.
    *   `DX` = куда класть данные (буфер).
*   **Выход:** `AX` = количество прочитанных байт. Если AX=0, значит файл кончился (EOF).

### Закрытие файла (AH = 3Eh)
Обязательно закрывайте файлы, иначе данные могут не сохраниться!
*   **Вход:** `BX` = дескриптор.

---

## 3. Системные функции (Время и Дата)

### Получение текущей даты (AH = 2Ah)
*   **Выход:**
    *   `CX` = Год (например, 2023).
    *   `DH` = Месяц (1-12).
    *   `DL` = День (1-31).
    *   `AL` = День недели (0=Вс, 1=Пн...).

### Получение текущего времени (AH = 2Ch)
*   **Выход:**
    *   `CH` = Часы.
    *   `CL` = Минуты.
    *   `DH` = Секунды.
    *   `DL` = Сотые доли секунды.

---

## 4. Пример: Запись введенной фразы в файл
Этот пример объединяет ввод строки и запись в файл. Это классическая задача.

```asm
.model small
.stack 100h

.data
    filename db 'output.txt', 0  ; Имя файла (заканчивается 0)
    
    ; Буфер для ввода (макс 50 символов)
    maxLen   db 50
    realLen  db ?                ; Сюда DOS запишет длину
    textData db 50 dup(?)        ; Место для текста
    
    prompt   db 'Enter text: $'
    errMsg   db 'Error!$'
    okMsg    db 0Dh, 0Ah, 'Saved to output.txt$' ; Переход строки + текст

    fileHandle dw ?              ; Переменная для хранения номера файла

.code
start:
    mov ax, @data
    mov ds, ax

    ; 1. Выводим приглашение "Enter text: "
    mov ah, 09h
    lea dx, prompt
    int 21h

    ; 2. Читаем строку с клавиатуры (функция 0Ah)
    mov ah, 0Ah
    lea dx, maxLen    ; Указываем на начало структуры буфера
    int 21h

    ; 3. Создаем файл
    mov ah, 3Ch
    mov cx, 0         ; Атрибуты (обычный файл)
    lea dx, filename
    int 21h
    jc error_handler  ; Если ошибка (Jump if Carry), прыгаем на метку ошибки

    mov fileHandle, ax ; Сохраняем полученный номер файла

    ; 4. Записываем данные в файл
    mov ah, 40h
    mov bx, fileHandle ; В BX кладем номер файла
    
    mov ch, 0
    mov cl, realLen    ; В CX кладем длину введенного текста (из буфера)
    lea dx, textData   ; В DX - адрес самого текста
    int 21h

    ; 5. Закрываем файл
    mov ah, 3Eh
    mov bx, fileHandle
    int 21h

    ; 6. Сообщаем об успехе
    mov ah, 09h
    lea dx, okMsg
    int 21h
    jmp final

error_handler:
    mov ah, 09h
    lea dx, errMsg
    int 21h

final:
    mov ah, 4Ch
    int 21h
end start
```

## Шпаргалка по регистрам для INT 21h

| Регистр | Роль                                                                  |
| :------ | :-------------------------------------------------------------------- |
| **AH**  | Номер функции (всегда!).                                              |
| **AL**  | Часто используется для возврата результата (код символа, код ошибки). |
| **DX**  | Почти всегда указывает адрес данных (строки, буфера, имени файла).    |
| **CX**  | Обычно счетчик (сколько байт записать/прочитать) или год.             |
| **BX**  | Обычно дескриптор файла (handle).                                     |

Если вы работаете с TASM, я очень рекомендую найти справочник "Ralf Brown's Interrupt List" или использовать встроенную справку в старых IDE, но для начала этих функций вам хватит на 90% студенческих задач.

---


# 4.Макросы

Макрос в TASM — это кусок кода, которому вы даете имя. Когда компилятор встречает это имя в программе, он просто копирует (подставляет) содержимое макроса в это место. Это очень удобно, чтобы не писать одни и те же команды (`mov ah, 09h`, `int 21h` и т.д.) по сто раз.

### 1. Базовый синтаксис

Макрос объявляется **до** сегмента кода (обычно в самом начале файла).

```asm
Имя_Макроса MACRO [параметр1, параметр2]
    ; Твой код
    ; В коде используешь параметры как обычные слова
ENDM
```

---

### 2. Простой пример: Макрос вывода строки

Обычно, чтобы вывести строку, вы пишете 3 строки кода. Сделаем макрос `Print`.

```asm
Print MACRO text_address
    mov ah, 09h
    mov dx, offset text_address ; подставляем параметр
    int 21h
ENDM
```

Теперь в коде вместо трех строк можно писать одну: `Print msg1`.

---

### 3. Важный нюанс: Метки внутри макроса (`LOCAL`)

Если внутри макроса есть циклы или переходы (метки), нужно использовать директиву **`LOCAL`**.
**Почему?** Если вы вызовете макрос два раза, компилятор вставит код два раза. Если там будет метка (например, `loop_start:`), то получится две метки с одинаковым именем — будет ошибка "Duplicate symbol".

`LOCAL` создает уникальные имена меток для каждого вызова.

**Пример: Макрос задержки (пустой цикл)**
```asm
Delay MACRO
    LOCAL wait_loop    ; Объявляем метку локальной
    
    mov cx, 0FFFFh     ; Счетчик
wait_loop:             ; Эта метка будет уникальной при каждом вызове
    dec cx
    jnz wait_loop
ENDM
```

---

### 4. Полный пример программы с макросами

Вот ваш предыдущий код, переписанный красиво с использованием макросов.

```asm
; --- ОБЪЯВЛЕНИЕ МАКРОСОВ ---

; Макрос для вывода строки
PrintStr MACRO str_name
    mov ah, 09h
    mov dx, offset str_name
    int 21h
ENDM

; Макрос для выхода из программы
ExitDOS MACRO
    mov ah, 4Ch
    int 21h
ENDM

; --- САМА ПРОГРАММА ---
.model small
.stack 100h

.data 
    msg1 db 'Hello Macro World!', 10, 13, '$'
    msg2 db 'It works perfect.', 10, 13, '$'

.code
start:
    mov ax, @data
    mov ds, ax

    ; Используем наши макросы
    PrintStr msg1     ; Развернется в 3 команды
    PrintStr msg2     ; Снова развернется в 3 команды

    ExitDOS           ; Развернется в 2 команды выхода

end start
```

### 5. Советы
1.  **Где писать:** Макросы лучше писать в самом верху файла или выносить в отдельный файл (например, `macros.inc`) и подключать командой `include macros.inc`.
2.  **Регистры:** Будьте осторожны. Если ваш макрос меняет регистры (например, `AX` или `CX`), а вы хранили там важные данные, программа сломается. Хорошим тоном считается сохранять регистры в стек (`push ax` ... `pop ax`) внутри макроса, если он делает что-то сложное.

Пример безопасного макроса (сохраняет регистры):
```asm
SafePrint MACRO text
    push ax         ; Сохранили текущее значение AX
    push dx         ; Сохранили DX

    mov ah, 09h
    mov dx, offset text
    int 21h

    pop dx          ; Вернули DX
    pop ax          ; Вернули AX
ENDM
```





 ---

# 5. Арифметика (Калькулятор внутри процессора)

Ассемблер не прощает вольного обращения с математикой. Здесь нельзя просто написать `a = b * c + d`. Каждое действие — это отдельная команда, и процессор очень придирчив к размерам данных.

## 1. Базовая математика (Сложение и Вычитание)

Здесь всё просто и логично. Работает так же, как и `MOV`.

### Команды
*   **`ADD куда, что`** — Сложение (`куда = куда + что`).
*   **`SUB куда, что`** — Вычитание (`куда = куда - что`).
*   **`INC куда`** — Инкремент (Увеличить на 1). Быстрее и короче, чем `add x, 1`.
*   **`DEC куда`** — Декремент (Уменьшить на 1).

### Золотое правило размеров
Операнды **обязаны** быть одного размера.
```asm
mov ax, 100     ; 16 бит
mov bl, 50      ; 8 бит

add ax, bx      ; ОШИБКА! (16 + 16)
add ax, bl      ; ОШИБКА! (16 + 8)

; Как правильно:
add al, bl      ; (8 + 8) - ОК
add ax, 50      ; (16 + число) - ОК
```

---

## 2. Смена знака (NEG)

Как сделать из `5` число `-5`?
Команда **`NEG`** (Negate) переворачивает знак числа (делает "дополнительный код").

```asm
mov ax, 5
neg ax          ; Теперь AX = -5 (или FFFBh в hex)
add ax, 5       ; Теперь AX = 0
```

---

## 3. Умножение (MUL и IMUL)

Вот тут начинается магия (и головная боль). В процессоре x86 **всегда один операнд скрытый**. Вы указываете только *на что* умножать, а *что* умножать — процессор решает сам жестко.

Есть две команды:
1.  **`MUL источник`** — для беззнаковых чисел (`0..255`).
2.  **`IMUL источник`** — для чисел со знаком (`-128..+127`).

### Таблица "Кто с кем и куда"

Результат умножения часто не влезает в тот же размер (байт * байт = слово), поэтому процессор использует регистры большего размера для результата.

| Вы пишете | Что делает процессор | Где результат |
| :--- | :--- | :--- |
| `MUL BL` (8 бит) | `AL` * `BL` | **AX** (16 бит) |
| `MUL BX` (16 бит) | `AX` * `BX` | **DX:AX** (32 бита!) |

**Что такое DX:AX?**
Это "двойной регистр". Старшая часть числа (верхние 16 бит) лежит в **DX**, младшая — в **AX**.
*   *Если результат маленький:* DX будет равен 0.
*   *Если результат огромный:* DX будет содержать данные.

**Пример:**
```asm
mov al, 100
mov bl, 4
mul bl          ; AX = 100 * 4 = 400.
                ; Результат (400) не влез бы в AL (макс 255), но в AX влезет.
```

---

## 4. Деление (DIV и IDIV)

Самая опасная операция. Если вы делите на ноль или **результат деления слишком большой и не влезает в регистр**, программа падает с ошибкой `Divide Overflow` (и DOSBox закрывается или виснет).

Команды:
1.  **`DIV источник`** — Беззнаковое деление.
2.  **`IDIV источник`** — Знаковое деление.

### Таблица "Кого и куда"

Деление — это операция, обратная умножению. Делимое (то, что делим) должно быть **в 2 раза больше** делителя.

| Вы пишете (Делитель) | Что делит процессор (Делимое) | Результат (Частное) | Остаток |
| :--- | :--- | :--- | :--- |
| `DIV BL` (8 бит) | **AX** (16 бит) | **AL** | **AH** |
| `DIV BX` (16 бит) | **DX:AX** (32 бита) | **AX** | **DX** |

### Главный "подводный камень" деления
Допустим, вы хотите разделить `AX` на `BX`. Вы думаете: "ну в AX же лежит число".
Но команда `DIV BX` берет число из связки **DX:AX**!
Если в `DX` остался какой-то мусор от предыдущих команд, процессор подумает, что вы делите гигантское число (например, 2 миллиона) на маленькое, результат не влезет в `AX`, и **программа упадет**.

**Правило:** Перед делением 16-битных чисел всегда **обнуляйте DX**!

```asm
; Задача: Поделить 1000 на 5
mov ax, 1000
mov bx, 5

xor dx, dx      ; ОБЯЗАТЕЛЬНО! Обнуляем DX (то же, что mov dx, 0)
div bx          ; Делим DX:AX на BX

; Теперь:
; AX = 200 (частное)
; DX = 0 (остаток)
```

---

## 5. Знаковое расширение (CBW и CWD)

Если вы работаете с отрицательными числами (`IDIV`), просто обнулять регистры нельзя (потеряете знак). Нужно "растянуть" знак числа на старший регистр.

Для этого есть специальные команды (без аргументов):
1.  **`CBW`** (Convert Byte to Word): Берет `AL`, смотрит на знак, и заполняет `AH`. (Делает из байта слово).
2.  **`CWD`** (Convert Word to Double): Берет `AX`, смотрит на знак, и заполняет `DX`. (Делает из слова двойное слово).

**Пример правильного знакового деления:**
```asm
; Задача: -100 / 5
mov ax, -100
mov bx, 5

cwd             ; Растягиваем -100 из AX на DX:AX. 
                ; DX станет FFFFh (знак минус), а не 0000h!
idiv bx         

; Результат в AX = -20
```

---

## 6. Практический пример: Вычисление формулы
Реализуем формулу: `Y = (A + B) * C / D`
Где все переменные — 16-битные слова.

```asm
.model small
.stack 100h
.data
    varA dw 10
    varB dw 20
    varC dw 5
    varD dw 2       ; Делитель
    result dw ?     ; Сюда положим ответ
    ostatok dw ?    ; Сюда остаток

.code
start:
    mov ax, @data
    mov ds, ax

    ; 1. Сложение (A + B)
    mov ax, varA    ; AX = 10
    add ax, varB    ; AX = 30

    ; 2. Умножение на C. Результат будет в DX:AX
    mul varC        ; AX * 5 -> DX:AX. 
                    ; 30 * 5 = 150. (DX=0, AX=150)

    ; 3. Деление на D. Делим пару DX:AX на varD
    ; Важно: DX у нас уже заполнен правильно после умножения 
    ; (если число было небольшим, там 0, если большим - часть числа).
    ; Поэтому вручную обнулять DX тут НЕ НАДО, мы делим результат умножения.
    div varD        ; 150 / 2

    ; 4. Сохранение результата
    mov result, ax  ; Частное (75)
    mov ostatok, dx ; Остаток (0)

    ; Выход
    mov ah, 4Ch
    int 21h
end start
```

## Шпаргалка "Почему не работает?"

1.  **`Operand types do not match`**: Пытаешься сложить 8-битный регистр с 16-битным (`add ax, bl`).
2.  **`Divide Overflow`**:
    *   Либо делишь на 0.
    *   Либо забыл очистить `DX` (или `AH`) перед делением.
    *   Либо результат деления больше, чем может вместить регистр.
3.  **Отрицательные числа ведут себя странно**: Использовал `MUL/DIV` вместо `IMUL/IDIV` или забыл сделать `CWD`.




# 6.Условные переходы

Чтобы разобраться в условных переходах «по-взрослому», нужно понять, что происходит внутри процессора. Условный переход — это не магия, а реакция на состояние регистра **FLAGS** (регистр флагов).

Вот подробный разбор механики, различий и приемов использования в TASM.

---

### 1. Физика процесса: Регистр FLAGS

Когда вы делаете `CMP A, B` или `SUB A, B`, процессор меняет биты в специальном регистре флагов. Условный переход (`Jxx`) просто смотрит на эти биты.

Самые важные флаги для переходов:
1.  **ZF (Zero Flag):** Устанавливается в **1**, если результат операции равен **0**.
    *   *Пример:* `CMP 5, 5` -> (5 - 5 = 0) -> **ZF=1**.
2.  **CF (Carry Flag):** Флаг переноса/заема. Работает с беззнаковой арифметикой. Если мы вычли из меньшего большее (без знака), случается заем, и **CF=1**.
3.  **SF (Sign Flag):** Копирует старший бит результата. Если результат отрицательный, **SF=1**.
4.  **OF (Overflow Flag):** Флаг переполнения. Важен **только для чисел со знаком**. Срабатывает, если результат не влезает в разрядную сетку (например, 127 + 1 в байте = -128).

---

### 2. Как формируется условие (Инструкция CMP)

Инструкция `CMP op1, op2` — это «вычитание понарошку».
Она делает `op1 - op2`, выставляет флаги, но **не записывает** результат никуда.

*   Если `op1 == op2`: Результат 0, значит **ZF=1**.
*   Если `op1 < op2`:
    *   Без знака: Происходит заем, **CF=1**.
    *   Со знаком: Результат отрицательный (обычно SF != OF).

**Важно:** Флаги могут установить и другие инструкции (`AND`, `OR`, `SUB`, `ADD`, `DEC`, `INC`). `MOV` флаги **не трогает**.

---

### 3. Глубокий разбор: Знаковые vs Беззнаковые

Это самая частая ошибка новичков. В памяти компьютера число `11111111` (байт) — это одновременно и **255** (без знака), и **-1** (со знаком).

Процессор не знает, что вы имеете в виду, поэтому дает вам два набора команд:

#### Набор 1: Беззнаковые числа (Unsigned) — `0...255`
Используют слова **Above** (Выше) и **Below** (Ниже). Смотрят в основном на флаг **CF**.

| Команда | Условие флагов | Логика (после CMP A, B) |
| :--- | :--- | :--- |
| **JB** (Jump Below) | CF = 1 | Прыгнуть, если A < B (была необходимость занять разряд при вычитании) |
| **JAE** (Jump Above/Equal)| CF = 0 | Прыгнуть, если A >= B |
| **JA** (Jump Above) | CF = 0 и ZF = 0 | Прыгнуть, если A > B |
| **JBE** (Jump Below/Equal)| CF = 1 или ZF = 1| Прыгнуть, если A <= B |

#### Набор 2: Знаковые числа (Signed) — `-128...+127`
Используют слова **Greater** (Больше) и **Less** (Меньше). Смотрят на сложную комбинацию **SF** и **OF**.

| Команда | Условие флагов | Логика (после CMP A, B) |
| :--- | :--- | :--- |
| **JL** (Jump Less) | SF ≠ OF | Прыгнуть, если A < B (с учетом знака) |
| **JGE** (Jump Greater/Equal)| SF = OF | Прыгнуть, если A >= B |
| **JG** (Jump Greater) | ZF = 0 и SF = OF | Прыгнуть, если A > B |
| **JLE** (Jump Less/Equal) | ZF = 1 или SF ≠ OF | Прыгнуть, если A <= B |

**Пример катастрофы:**
```assembly
mov al, 255   ; В знаковом это -1
mov bl, 5     ; Это 5

cmp al, bl    ; Сравниваем
jg  metka     ; НЕ прыгнет (потому что -1 НЕ больше 5)
ja  metka     ; ПРЫГНЕТ (потому что 255 больше 5)
```

---

### 4. Специфические переходы (по конкретным флагам)

Иногда вам не нужно сравнивать числа, а нужно проверить состояние после логической операции или ошибки.

*   **JC** (Jump Carry) / **JNC** (No Carry): Часто используется после арифметики, чтобы проверить переполнение буфера или результат системной функции (многие прерывания `INT 21h` ставят CF=1 при ошибке).
*   **JP** (Jump Parity) / **JNP**: Прыжок по четности битов (используется редко, в основном в криптографии или старых протоколах связи).
*   **JS** (Jump Sign) / **JNS**: Прыжок, если число просто стало отрицательным.
*   **JO** (Jump Overflow): Прыжок, если произошло математическое переполнение знакового числа.

---

### 5. Проблема "Short Jump" и директива JUMPS

В классическом 8086/DOS инструкции условного перехода (например, `JE`) могут прыгать только на **-128 ... +127 байт** от текущего места. Это очень мало.

Если ваша метка `target:` находится за 500 строк кода от перехода, TASM выдаст ошибку: `Relative jump out of range`.

**Решение 1 (Ручное - "Трамплин"):**
```assembly
    cmp ax, bx
    je  target      ; ОШИБКА: слишком далеко
    
    ; Меняем на:
    jne skip        ; Если НЕ равно, пропускаем прыжок
    jmp target      ; JMP (безусловный) умеет прыгать далеко
skip:
    ; продолжение кода
```

**Решение 2 (Автоматическое - фишка TASM):**
Поставьте директиву `JUMPS` в начале кода (перед `.model`). TASM сам автоматически переделает все далекие условные переходы в "трамплины".

```assembly
JUMPS      ; Включить умные прыжки
.model small
...
    je far_label ; Теперь это сработает, TASM сам сгенерирует код с jmp
```

---

### 6. Паттерны программирования (IF / WHILE)

В ассемблере нет фигурных скобок. Мы строим структуры сами.

#### Реализация IF-ELSE
Высокий уровень:
```cpp
if (ax == 5) {
    // блок TRUE
} else {
    // блок FALSE
}
```

Ассемблер:
```assembly
    cmp ax, 5
    jne do_else     ; Условие ложно? Иди в ELSE

    ; -- Блок TRUE --
    ; (код здесь)
    jmp end_if      ; ВАЖНО: перепрыгнуть блок ELSE!

do_else:
    ; -- Блок FALSE --
    ; (код здесь)

end_if:
    ; -- Продолжение --
```

#### Реализация цикла WHILE
Высокий уровень:
```cpp
while (cx > 0) {
    cx--;
}
```

Ассемблер:
```assembly
loop_start:
    cmp cx, 0
    jle loop_end    ; Если условие нарушено (<= 0), выход из цикла
    
    ; -- Тело цикла --
    dec cx
    
    jmp loop_start  ; Прыжок обратно на проверку
loop_end:
```

### 7. Полезный трюк: Инструкция TEST

Часто нужно проверить, равен ли регистр нулю, или проверить конкретный бит. Вместо `CMP AX, 0` профессионалы используют `TEST`.

*   **`TEST AX, AX`**: Делает логическое И (AND) регистра с самим собой. Значение не меняется, но флаги обновляются.
    *   Это быстрее и короче (по байтам), чем `CMP AX, 0`.
    *   Используется с `JZ` (если ноль) или `JS` (если отрицательное).

*   **`TEST AL, 00000001b`**: Проверить, установлен ли 0-й бит (является ли число нечетным).
    *   `JNZ is_odd` (Если результат не ноль, значит бит был равен 1).