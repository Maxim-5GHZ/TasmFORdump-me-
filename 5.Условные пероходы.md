Чтобы разобраться в условных переходах «по-взрослому», нужно понять, что происходит внутри процессора. Условный переход — это не магия, а реакция на состояние регистра **FLAGS** (регистр флагов).

Вот подробный разбор механики, различий и приемов использования в TASM.

---

### 1. Физика процесса: Регистр FLAGS

Когда вы делаете `CMP A, B` или `SUB A, B`, процессор меняет биты в специальном регистре флагов. Условный переход (`Jxx`) просто смотрит на эти биты.

Самые важные флаги для переходов:
1.  **ZF (Zero Flag):** Устанавливается в **1**, если результат операции равен **0**.
    *   *Пример:* `CMP 5, 5` -> (5 - 5 = 0) -> **ZF=1**.
2.  **CF (Carry Flag):** Флаг переноса/заема. Работает с беззнаковой арифметикой. Если мы вычли из меньшего большее (без знака), случается заем, и **CF=1**.
3.  **SF (Sign Flag):** Копирует старший бит результата. Если результат отрицательный, **SF=1**.
4.  **OF (Overflow Flag):** Флаг переполнения. Важен **только для чисел со знаком**. Срабатывает, если результат не влезает в разрядную сетку (например, 127 + 1 в байте = -128).

---

### 2. Как формируется условие (Инструкция CMP)

Инструкция `CMP op1, op2` — это «вычитание понарошку».
Она делает `op1 - op2`, выставляет флаги, но **не записывает** результат никуда.

*   Если `op1 == op2`: Результат 0, значит **ZF=1**.
*   Если `op1 < op2`:
    *   Без знака: Происходит заем, **CF=1**.
    *   Со знаком: Результат отрицательный (обычно SF != OF).

**Важно:** Флаги могут установить и другие инструкции (`AND`, `OR`, `SUB`, `ADD`, `DEC`, `INC`). `MOV` флаги **не трогает**.

---

### 3. Глубокий разбор: Знаковые vs Беззнаковые

Это самая частая ошибка новичков. В памяти компьютера число `11111111` (байт) — это одновременно и **255** (без знака), и **-1** (со знаком).

Процессор не знает, что вы имеете в виду, поэтому дает вам два набора команд:

#### Набор 1: Беззнаковые числа (Unsigned) — `0...255`
Используют слова **Above** (Выше) и **Below** (Ниже). Смотрят в основном на флаг **CF**.

| Команда | Условие флагов | Логика (после CMP A, B) |
| :--- | :--- | :--- |
| **JB** (Jump Below) | CF = 1 | Прыгнуть, если A < B (была необходимость занять разряд при вычитании) |
| **JAE** (Jump Above/Equal)| CF = 0 | Прыгнуть, если A >= B |
| **JA** (Jump Above) | CF = 0 и ZF = 0 | Прыгнуть, если A > B |
| **JBE** (Jump Below/Equal)| CF = 1 или ZF = 1| Прыгнуть, если A <= B |

#### Набор 2: Знаковые числа (Signed) — `-128...+127`
Используют слова **Greater** (Больше) и **Less** (Меньше). Смотрят на сложную комбинацию **SF** и **OF**.

| Команда | Условие флагов | Логика (после CMP A, B) |
| :--- | :--- | :--- |
| **JL** (Jump Less) | SF ≠ OF | Прыгнуть, если A < B (с учетом знака) |
| **JGE** (Jump Greater/Equal)| SF = OF | Прыгнуть, если A >= B |
| **JG** (Jump Greater) | ZF = 0 и SF = OF | Прыгнуть, если A > B |
| **JLE** (Jump Less/Equal) | ZF = 1 или SF ≠ OF | Прыгнуть, если A <= B |

**Пример катастрофы:**
```assembly
mov al, 255   ; В знаковом это -1
mov bl, 5     ; Это 5

cmp al, bl    ; Сравниваем
jg  metka     ; НЕ прыгнет (потому что -1 НЕ больше 5)
ja  metka     ; ПРЫГНЕТ (потому что 255 больше 5)
```

---

### 4. Специфические переходы (по конкретным флагам)

Иногда вам не нужно сравнивать числа, а нужно проверить состояние после логической операции или ошибки.

*   **JC** (Jump Carry) / **JNC** (No Carry): Часто используется после арифметики, чтобы проверить переполнение буфера или результат системной функции (многие прерывания `INT 21h` ставят CF=1 при ошибке).
*   **JP** (Jump Parity) / **JNP**: Прыжок по четности битов (используется редко, в основном в криптографии или старых протоколах связи).
*   **JS** (Jump Sign) / **JNS**: Прыжок, если число просто стало отрицательным.
*   **JO** (Jump Overflow): Прыжок, если произошло математическое переполнение знакового числа.

---

### 5. Проблема "Short Jump" и директива JUMPS

В классическом 8086/DOS инструкции условного перехода (например, `JE`) могут прыгать только на **-128 ... +127 байт** от текущего места. Это очень мало.

Если ваша метка `target:` находится за 500 строк кода от перехода, TASM выдаст ошибку: `Relative jump out of range`.

**Решение 1 (Ручное - "Трамплин"):**
```assembly
    cmp ax, bx
    je  target      ; ОШИБКА: слишком далеко
    
    ; Меняем на:
    jne skip        ; Если НЕ равно, пропускаем прыжок
    jmp target      ; JMP (безусловный) умеет прыгать далеко
skip:
    ; продолжение кода
```

**Решение 2 (Автоматическое - фишка TASM):**
Поставьте директиву `JUMPS` в начале кода (перед `.model`). TASM сам автоматически переделает все далекие условные переходы в "трамплины".

```assembly
JUMPS      ; Включить умные прыжки
.model small
...
    je far_label ; Теперь это сработает, TASM сам сгенерирует код с jmp
```

---

### 6. Паттерны программирования (IF / WHILE)

В ассемблере нет фигурных скобок. Мы строим структуры сами.

#### Реализация IF-ELSE
Высокий уровень:
```cpp
if (ax == 5) {
    // блок TRUE
} else {
    // блок FALSE
}
```

Ассемблер:
```assembly
    cmp ax, 5
    jne do_else     ; Условие ложно? Иди в ELSE

    ; -- Блок TRUE --
    ; (код здесь)
    jmp end_if      ; ВАЖНО: перепрыгнуть блок ELSE!

do_else:
    ; -- Блок FALSE --
    ; (код здесь)

end_if:
    ; -- Продолжение --
```

#### Реализация цикла WHILE
Высокий уровень:
```cpp
while (cx > 0) {
    cx--;
}
```

Ассемблер:
```assembly
loop_start:
    cmp cx, 0
    jle loop_end    ; Если условие нарушено (<= 0), выход из цикла
    
    ; -- Тело цикла --
    dec cx
    
    jmp loop_start  ; Прыжок обратно на проверку
loop_end:
```

### 7. Полезный трюк: Инструкция TEST

Часто нужно проверить, равен ли регистр нулю, или проверить конкретный бит. Вместо `CMP AX, 0` профессионалы используют `TEST`.

*   **`TEST AX, AX`**: Делает логическое И (AND) регистра с самим собой. Значение не меняется, но флаги обновляются.
    *   Это быстрее и короче (по байтам), чем `CMP AX, 0`.
    *   Используется с `JZ` (если ноль) или `JS` (если отрицательное).

*   **`TEST AL, 00000001b`**: Проверить, установлен ли 0-й бит (является ли число нечетным).
    *   `JNZ is_odd` (Если результат не ноль, значит бит был равен 1).