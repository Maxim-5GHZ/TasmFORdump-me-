Конечно. Арифметика в ассемблере — это та часть, где вы почувствуете себя либо богом оптимизации, либо человеком, который не понимает, почему `2 * 2` обрушило программу.

---

Ассемблер не прощает вольного обращения с математикой. Здесь нельзя просто написать `a = b * c + d`. Каждое действие — это отдельная команда, и процессор очень придирчив к размерам данных.

## 1. Базовая математика (Сложение и Вычитание)

Здесь всё просто и логично. Работает так же, как и `MOV`.

### Команды
*   **`ADD куда, что`** — Сложение (`куда = куда + что`).
*   **`SUB куда, что`** — Вычитание (`куда = куда - что`).
*   **`INC куда`** — Инкремент (Увеличить на 1). Быстрее и короче, чем `add x, 1`.
*   **`DEC куда`** — Декремент (Уменьшить на 1).

### Золотое правило размеров
Операнды **обязаны** быть одного размера.
```asm
mov ax, 100     ; 16 бит
mov bl, 50      ; 8 бит

add ax, bx      ; ОШИБКА! (16 + 16)
add ax, bl      ; ОШИБКА! (16 + 8)

; Как правильно:
add al, bl      ; (8 + 8) - ОК
add ax, 50      ; (16 + число) - ОК
```

---

## 2. Смена знака (NEG)

Как сделать из `5` число `-5`?
Команда **`NEG`** (Negate) переворачивает знак числа (делает "дополнительный код").

```asm
mov ax, 5
neg ax          ; Теперь AX = -5 (или FFFBh в hex)
add ax, 5       ; Теперь AX = 0
```

---

## 3. Умножение (MUL и IMUL)

Вот тут начинается магия (и головная боль). В процессоре x86 **всегда один операнд скрытый**. Вы указываете только *на что* умножать, а *что* умножать — процессор решает сам жестко.

Есть две команды:
1.  **`MUL источник`** — для беззнаковых чисел (`0..255`).
2.  **`IMUL источник`** — для чисел со знаком (`-128..+127`).

### Таблица "Кто с кем и куда"

Результат умножения часто не влезает в тот же размер (байт * байт = слово), поэтому процессор использует регистры большего размера для результата.

| Вы пишете | Что делает процессор | Где результат |
| :--- | :--- | :--- |
| `MUL BL` (8 бит) | `AL` * `BL` | **AX** (16 бит) |
| `MUL BX` (16 бит) | `AX` * `BX` | **DX:AX** (32 бита!) |

**Что такое DX:AX?**
Это "двойной регистр". Старшая часть числа (верхние 16 бит) лежит в **DX**, младшая — в **AX**.
*   *Если результат маленький:* DX будет равен 0.
*   *Если результат огромный:* DX будет содержать данные.

**Пример:**
```asm
mov al, 100
mov bl, 4
mul bl          ; AX = 100 * 4 = 400.
                ; Результат (400) не влез бы в AL (макс 255), но в AX влезет.
```

---

## 4. Деление (DIV и IDIV)

Самая опасная операция. Если вы делите на ноль или **результат деления слишком большой и не влезает в регистр**, программа падает с ошибкой `Divide Overflow` (и DOSBox закрывается или виснет).

Команды:
1.  **`DIV источник`** — Беззнаковое деление.
2.  **`IDIV источник`** — Знаковое деление.

### Таблица "Кого и куда"

Деление — это операция, обратная умножению. Делимое (то, что делим) должно быть **в 2 раза больше** делителя.

| Вы пишете (Делитель) | Что делит процессор (Делимое) | Результат (Частное) | Остаток |
| :--- | :--- | :--- | :--- |
| `DIV BL` (8 бит) | **AX** (16 бит) | **AL** | **AH** |
| `DIV BX` (16 бит) | **DX:AX** (32 бита) | **AX** | **DX** |

### Главный "подводный камень" деления
Допустим, вы хотите разделить `AX` на `BX`. Вы думаете: "ну в AX же лежит число".
Но команда `DIV BX` берет число из связки **DX:AX**!
Если в `DX` остался какой-то мусор от предыдущих команд, процессор подумает, что вы делите гигантское число (например, 2 миллиона) на маленькое, результат не влезет в `AX`, и **программа упадет**.

**Правило:** Перед делением 16-битных чисел всегда **обнуляйте DX**!

```asm
; Задача: Поделить 1000 на 5
mov ax, 1000
mov bx, 5

xor dx, dx      ; ОБЯЗАТЕЛЬНО! Обнуляем DX (то же, что mov dx, 0)
div bx          ; Делим DX:AX на BX

; Теперь:
; AX = 200 (частное)
; DX = 0 (остаток)
```

---

## 5. Знаковое расширение (CBW и CWD)

Если вы работаете с отрицательными числами (`IDIV`), просто обнулять регистры нельзя (потеряете знак). Нужно "растянуть" знак числа на старший регистр.

Для этого есть специальные команды (без аргументов):
1.  **`CBW`** (Convert Byte to Word): Берет `AL`, смотрит на знак, и заполняет `AH`. (Делает из байта слово).
2.  **`CWD`** (Convert Word to Double): Берет `AX`, смотрит на знак, и заполняет `DX`. (Делает из слова двойное слово).

**Пример правильного знакового деления:**
```asm
; Задача: -100 / 5
mov ax, -100
mov bx, 5

cwd             ; Растягиваем -100 из AX на DX:AX. 
                ; DX станет FFFFh (знак минус), а не 0000h!
idiv bx         

; Результат в AX = -20
```

---

## 6. Практический пример: Вычисление формулы
Реализуем формулу: `Y = (A + B) * C / D`
Где все переменные — 16-битные слова.

```asm
.model small
.stack 100h
.data
    varA dw 10
    varB dw 20
    varC dw 5
    varD dw 2       ; Делитель
    result dw ?     ; Сюда положим ответ
    ostatok dw ?    ; Сюда остаток

.code
start:
    mov ax, @data
    mov ds, ax

    ; 1. Сложение (A + B)
    mov ax, varA    ; AX = 10
    add ax, varB    ; AX = 30

    ; 2. Умножение на C. Результат будет в DX:AX
    mul varC        ; AX * 5 -> DX:AX. 
                    ; 30 * 5 = 150. (DX=0, AX=150)

    ; 3. Деление на D. Делим пару DX:AX на varD
    ; Важно: DX у нас уже заполнен правильно после умножения 
    ; (если число было небольшим, там 0, если большим - часть числа).
    ; Поэтому вручную обнулять DX тут НЕ НАДО, мы делим результат умножения.
    div varD        ; 150 / 2

    ; 4. Сохранение результата
    mov result, ax  ; Частное (75)
    mov ostatok, dx ; Остаток (0)

    ; Выход
    mov ah, 4Ch
    int 21h
end start
```

## Шпаргалка "Почему не работает?"

1.  **`Operand types do not match`**: Пытаешься сложить 8-битный регистр с 16-битным (`add ax, bl`).
2.  **`Divide Overflow`**:
    *   Либо делишь на 0.
    *   Либо забыл очистить `DX` (или `AH`) перед делением.
    *   Либо результат деления больше, чем может вместить регистр.
3.  **Отрицательные числа ведут себя странно**: Использовал `MUL/DIV` вместо `IMUL/IDIV` или забыл сделать `CWD`.


